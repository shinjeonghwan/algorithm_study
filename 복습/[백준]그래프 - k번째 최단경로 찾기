#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int N, M, K;


struct e_t{
    int node;
    int cost;
    e_t(int _node, int _cost) : node(_node), cost(_cost) {}
    bool operator<(const e_t &ref) const{
        return this->cost > ref.cost;     // c++에서는 기본적으로 max heap이기 때문에 min heap으로 동작시키려면 부등호의 방향이 < 에서 >로 변경해주어야 한다.
    }
};

vector<e_t> AL[1001];
//vector<long long> Visited[1001];  //해당 정점의 최단 도착 코스트 저장
priority_queue<long long> Visited[1001];    //굳이 PQ로 풀어야할까?? 하는 의문이 존재

int main(){
    scanf("%d %d %d", &N, &M, &K);

    int a, b, c;
    for (int i = 0; i< M; i++){
        scanf("%d %d %d", &a, &b, &c);
        //AL[a].push_back({b,c});
        AL[a].push_back(e_t(b,c));
    }

    // processing (다익스트라)
    priority_queue<e_t> PQ; // cost에 대한 min heap 형태로 동작해야 함.


    Visited[1].push(0);
    PQ.push(e_t(1, 0));

    while(!PQ.empty()){
        e_t cur = PQ.top();
        PQ.pop();
        for(e_t next : AL[cur.node]){
            int cost = cur.cost + next.cost;
            if(Visited[next.node].size() == K && cost < Visited[next.node].top()){    //굳이 size() == K 와 같은 문항이 필요할까? 하는 의문 존재
                Visited[next.node].pop();
            }
            if(Visited[next.node].size() < K){
                Visited[next.node].push(cost);
                PQ.push(e_t(next.node, cost));
            }
        }
    }

    for (int i = 1; i<=N; i++){
        if (Visited[i].size() < K){
            printf("-1\n");
        }
        else{
            printf("%d\n",Visited[i].top());
        }
    }
    return 0;
}

