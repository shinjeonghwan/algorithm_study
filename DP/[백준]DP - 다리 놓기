import math
import sys
from collections import defaultdict
from collections import deque
import itertools
from itertools import combinations
import math
sys.setrecursionlimit(1000000000)

def solution(T, bridge_list):
    for i in range(T):
        N, M = bridge_list[i]
        #ans = math.factorial(M) // (math.factorial(N) * math.factorial(M-N))
        ans = math.comb(M, N)
        print(ans)


if __name__ == '__main__':
    T = int(sys.stdin.readline().rstrip())
    bridge_list = [list(map(int, sys.stdin.readline().split())) for i in range(T)]

    solution(T, bridge_list)
    
    
    

==========================================================================================================

def solution(T, bridge_list):
    for i in range(T):
        N, M = bridge_list[i]
        d = [[1] * 31 for _ in range(31)]

        for i in range(31):
            d[1][i] = i

        for i in range(2, 31):
            for j in range(i+1, 31):
                d[i][j] = d[i][j-1] + d[i-1][j-1]

        print(d[N][M])



if __name__ == '__main__':
    T = int(sys.stdin.readline().rstrip())
    bridge_list = [list(map(int, sys.stdin.readline().split())) for i in range(T)]

    solution(T, bridge_list)
